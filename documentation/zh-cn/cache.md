# 缓存

缓存组件提供了简单的内存缓存，采用随机淘汰的驱逐策略，支持过期时间。

## 环境变量

| 环境变量                        | 说明                                                                 |
| :------------------------------ | :------------------------------------------------------------------- |
| CACHE_DEFAULT_EXPIRE_IN_SECONDS | 默认的存活时长，取值：1-3600，默认 60                                |
| CACHE_STAT_TASK_ENABLED         | 是否启用统计任务，启用后每隔指定的时间打印一次缓存统计信息，用于观察 |
| CACHE_STAT_INTERVAL             | 统计任务执行的周期,单位秒.取值 1-86400                               |
| CACHE_CLEANING_INTERVAL         | 过期数据清理间隔，单位秒.取值 1-3600，默认 60                        |
| CACHE_MAX_ELEMENTS              | 最大元素数，取值 1- Number.MAX_VALUE，默认 1024                      |

开启缓存的统计后，会按指定的周期，定时输出统计信息到日志。

```
[2023/09/27 11:31:35.690][INFO]Cache statistics，
time window ：2023/09/27 11:31:35.442 - now， hit ：4/4，capacity：120/100
```

上面是统计日志的示例，内容包含了命中情况，以及容量使用情况。上面的示例中容量超出了，这是因为清理任务还没有来的及清理导致的，属于正常。
统计是有时间窗口的，只统计这个周期内的情况，所以日志里会有窗口时间信息。

## 性能相关问题

CACHE_CLEANING_INTERVAL 用于控制缓存清理任务的周期，如果项目中缓存的内容较多，则必须需要设置的小一些，及时清理掉无效数据。
缓存的数据过多，会影响 gc ，因为回收器无法回收被缓存的对象，为此所做的标记和整理内存工作却有很大的消耗。除了清理要频繁一些外，
缓存记录时也尽可能将过期时间设置的短一些。

为了减少开销，缓存组件采用随机淘汰的驱逐策略，暂不支持设置驱逐策略。

如果需要大量数据的缓存，又不想不影响 gc，可以考虑其它方案，如堆外内存（Buffer），或者外部缓存服务（Redis 等）。
内存缓存只适合缓存少量短期数据。

## 示例

通过 getCache 函数可以获取到全局的缓存对象，通过对象的相关方法来使用缓存。

```ts
// 获取缓存对象
const cache = getCache()

// 使用默认过期时间
cache.put('abc', 123)
let value = cache.get('abc') // 123

// 指定过期时间（第三个参数，单位秒）
cache.put('d', 2233, 1)
// 删除缓存内容
cache.remove('d')
```

缓存对象有个 computeIfAbsent 方法，可以指定生成缓存内容的方法，
如果没有缓存数据则进行生成，有则直接返回缓存数据。

```ts
const user = await cache.computeIfAbsent(`get-user-${userId}`, findUserById(userId))
```
